Kubernetes

Docker: platform for creating immutable images. run containers.
Cons: Good for small systems. Not Enterprise scale.


Kubernetes: Containers + orchestration through service discovery
from Google project: Borg - minimal version of Borg


Kubernetes Master : K8S config service: takes in the configuration / workload definition (yaml/json) via API / UI / kubectl
talks to workers / nodes via kublets running on them.
nodes will pull the images from dockerhub or private docker registry


Minikube: Small one node cluster with k8s 1.3

K8s Multi-node Cluster: prod env

Google container engine - Google compute engine
-----------------------------------------------------
Terminology:
node: host
container: unit of packaging
pod: unit of deployment: homogenous containers. vms that bring up multiple containers and make them available as one. Containers that need to be together can be created as a pod.
contains one processid, network namespace
Replication Controller: ensures desired state of scalability and availability. ex: 3 pods always running
Labels: kv pairs. The keys that define the services and objects running in kubernetes containers
Services: collection of pods exposed as an endpoint
-----------------------------------------------------

Kubernetes Master components: 
API Server exposes a set of APIs for operations available
Scheduler: schedules pods across nodes that meets a particular criteria. 
Controller: Co-ordination & health of cluster.
etcd - lightweight, distributed key-value db. Stores cluster state.

kubectl - CLI that consumes APIs from API Server. - Go lang based
Kubernetes dashboard also uses the same API Server. All requests pass through this

Kubernetes Master talks to nodes. 
k8S master doesn't host any pods
-----------------------------------------------------
K8S Nodes / slave /Minions
Main components:

Contain kubeproxy - maintains network config. Manipulates ip tables on each host for pod to pod, node to node comm.
kubelet - agent that talks to API (master). reports health and state
docker - engine that creates containers

kubelet + docker = supervisord

fluentd - log management for central logging

Addons: DNS management, UI - help dev

-----------------------------------------------------
Starting minikube:

open cmd prompt, navigate to the location which contains minikube exe.
-----------------------------------------------------
minikube start --vm-driver=virtualbox

this starts a small kubernetes orchestrated cluster. 

These are visible in virtualbox

Also configures kubectl (client) to minikube

-----------------------------------------------------

minikube status

prints running / stopped status of the container
-----------------------------------------------------
minikube dashboard

pulls up a dashboard showing info on the cluster
-----------------------------------------------------
point docker cli to minikube:
Execute the following:
1. minikube docker-env

This outputs a bunch of variables.
Execute the last line: Since the delimiters have a problem in windows 10, add delims=ctrl+L to the command.
@FOR /f "tokens=* delims=^L" %i IN ('minikube docker-env') DO %i

Then execute docker commands on terminal
-----------------------------------------------------
Terminology:
node: host

container: unit of packaging

pod: unit of deployment: homogenous containers. vms that bring up multiple containers and make them available as one. Containers that need to be together can be created as a pod.

Replication Controller: ensures desired state of scalability and availability. ex: 3 pods always running

Labels: kv pairs. The keys that define the services and objects running in kubernetes containers

Services: collection of pods exposed as an endpoint

etcd - distributed kv pair db
-----------------------------------------------------
kubectl version
prints client and server versions of K8S
-----------------------------------------------------
kubectl cluster-info (dump)
prints out the info on the master and nodes
dump: option presents a verbose output of all the config
-----------------------------------------------------
kubectl get nodes
prints details on the running node
-----------------------------------------------------
kubectl get cs (component status)
prints status of different components
-----------------------------------------------------
kubectl config use-context <name>
switches the context to the different setup
-----------------------------------------------------
kubectl run my-web --image=nginx --port=80
Creates a deployment with name my-web

similar to docker run command
-----------------------------------------------------
kubectl get deployments

prints the deployment data: desired number of pods, current number, available ones etc.
-----------------------------------------------------
kubectl get pods
options:
 --show-labels

prints the details of the pods
--show-labels will display the labels that are associated with it.
pod-template-hash is generated by k8s to keep track of the updated deployments
-----------------------------------------------------
kubectl expose deployment my-web --target-port=80 --type=NodePort
creates a service that is accessible on port 80 internally

types:
ClusterIP: service is available only internally with in the pod
NodePort: exposes the service at Node's IP. ClusterIP service is auto created. NodePort will route to the ClusterIP service internally. Meant for outside contact.
LoadBalancer: exposes the service on the cloud provider's LB. NodePort and ClusterIP services are auto created.
More: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
-----------------------------------------------------
kubectl get svc / kubectl get services
prints the services with name, ip, port (Internal:external) along with protocol
-----------------------------------------------------
minikube ip
displays the ip of the k8s server
-----------------------------------------------------
kubectl describe svc <name>
prints the info on the service like the clusterIP, namespace, labels, publish type, endpoints etc.
-----------------------------------------------------
kubectl proxy
starts to serve a webapp on a url upon hitting which a list of APIs are returned.
-----------------------------------------------------
heapster - container essential for kubernetes master. Scheduling is disabled on K8S master node as itdoesnt host containers.
-----------------------------------------------------
Service is bound to the pod definition -- selector definition in service should match the  labels in pod definition.
----------------------------------------------------
kubectl create -f <yaml file with pod def>
creates a pod for that definiton
-----------------------------------------------------
kubectl delete pod <pod_name>
deletes the pod
----------------------------------------------------
kubectl delete svc <service_name>
deletes the service with this name
----------------------------------------------------
kubectl exec -it <pod> /bin/bash
to execute commands on the running container. Similar to docker exec.
----------------------------------------------------
Any of the nodes could be hosting the application. kube proxy will route them to the appropriate node properly. To know which nodes actually running the application execute kubectl describe pod
--------------------------------------------------- 
kubectl describe pod <name>
describes the pod of given name
---------------------------------------------------
REplication Controller -- number of pods
kubectl get rc

prints the data on Replication controller. Number desired, current number of pods age etc.
---------------------------------------------------
kubectl scale rc web replicas=10
scale the pods as desired outside of the cofig from ReplicationController definition

**useful when some pods need to be scaled temporarily
---------------------------------------------------
kubectl expose pod <name> --type=NodePort
exposes the said pod to the outside world. Creates a service in the background.

Another way would be to define a service.
---------------------------------------------------
kubectl describe svc / pod/ node <name> 
describes the said object.
---------------------------------------------------
Replication Controllers use labels and selectors to associate RC with pods
Replica sets are next gen RCs, they use Annotations and querying to associate with pods.
Can make the query very granular

---------------------------------------------------
Kubernetes Volume Types

Host based volumes: 
a. EmptyDir: temp, created when pod is scheduled. Ephemeral.
b. HostPath: Exposes on of the existent dirs to K8s. persistent.

Block Storage-based volumes:
like disks created on GCE. These disks are persistent and the data is not deleted even when the pod is deleted. However, they are not distributed, multiple pods cant access it at the same time.

Prod: storageClass recommended 

PersistentVolume (PV): network storage created by admin, governed by a quota.

PersistentVolumeClaim (PVC): Claims made on the PV by users. PV quota could be 5G. Claim could be for 1G.

StorageClass: drivers/interfaces. supported storage profiles offered by admins. example: nfs. 
Mentioned in the PersistentVolume object definition.

Claim needn't know the StorageClass. Only needs to know the max available capacity.


StatefulSets / Pecsets - stateful, persistent

---------------------------------------------------
Deployments:
Defines the state of application with config like: number of replicas, versions needed etc.
Create, update, perform rolling updates, rollback, pause/resume a deployment

kubectl create -f <file> --record
creates a deployment

kubectl get deployments
prints the deployments

kubectl set image deployment/<name> <image>:<image:newVersion>
updates the image to be deployed

where is this data on new version stored as the file has a different version. etcd?

kubectl rollout status deployment/<name>
prints status of roll out
---------------------------------------------------
kubectl edit deployment/<name>
opens an editable window for the deployment

the changes reflect immediately
---------------------------------------------------
kubectl rollout undo deployment/<name>
rollback of previous updates 
---------------------------------------------------
Exact external port can be deinfed by nodePort property in the service.
---------------------------------------------------
watch kubectl get pods

will print and update the information to reflect the current state of pods
---------------------------------------------------
kubectl rollout history deployment <name>
prints out the revisions of the deployment
---------------------------------------------------
kubectl delete deployment <name>
Deletes deployments
---------------------------------------------------
kubectl delete svc <name>
deletes the service
---------------------------------------------------
kubectl rollout pause <deployment>
pauses deployment
---------------------------------------------------
kubectl rollout resume <deployment>
resumes deployment
---------------------------------------------------
kubectl apply svc -f  yaml.yml
applies the changes to the existing service
---------------------------------------------------

The DNS of services are automatically resolve namespaces in the same cluster.

If services are from other cluster, use headless service, a router to point to the external service
---------------------------------------------------
kubernetes service loadbalancer = loadbalancer + proxy
---------------------------------------------------



